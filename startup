#!/bin/bash

ROOT_PATH=${START_UP_PATH:-$HOME/.startup}
CONFIG_FILE=${START_UP_CONFIG_PATH:-$ROOT_PATH/config}
KILL_WAIT=${START_UP_KILL_WAIT_TIME:-10}
LOCK_TIMEOUT=${START_UP_LOCK_TIMEOUT:-600}
TIME_ZONE=${START_UP_TIME_ZONE:-Asia/Shanghai}

MARKER_NAME="__STARTUP_${USER}_GUARD_UUID__"
STATE_DIR="$ROOT_PATH/states"

mkdir -p "$STATE_DIR"
cd "$STATE_DIR" || exit 1

log() {
    echo "[$(TZ=$TIME_ZONE date '+%F %T.%N')] $@"
}

_trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

_get_marker() {
    local pid=$1
    local LC_ALL=C 
    
    if [[ "$OSTYPE" == "freebsd"* ]]; then
        if command -v procstat >/dev/null 2>&1; then
            procstat -e "$pid" 2>/dev/null | tr ' ' '\n' | grep "^${MARKER_NAME}=" | cut -d= -f2
        fi
    else
        if [ -f "/proc/$pid/environ" ]; then
            tr '\0' '\n' < "/proc/$pid/environ" 2>/dev/null | grep "^${MARKER_NAME}=" | cut -d= -f2
        else
            ps -p "$pid" -eww 2>/dev/null | tr ' ' '\n' | grep "^${MARKER_NAME}=" | cut -d= -f2
        fi
    fi
}

_download_file() {
    local url=$1
    local out=$2
    log "downloading $url..."
    
    if command -v curl >/dev/null 2>&1; then
        curl -sL -o "$out" "$url"
    elif command -v wget >/dev/null 2>&1; then
        wget -qO "$out" "$url"
    elif command -v fetch >/dev/null 2>&1; then
        fetch -q -o "$out" "$url"
    else
        log "error: no download tool found"
        return 1
    fi

    if [ ! -s "$out" ]; then
        log "error: downloaded file is empty"
        rm -f "$out"
        return 1
    fi
}

_with_lock() {
    local name=$1; local action=$2; shift 2
    local lock="$STATE_DIR/$name.lock"

    if [ -d "$lock" ]; then
        local mtime=$(stat -c %Y "$lock" 2>/dev/null || stat -f %m "$lock" 2>/dev/null)
        local now=$(date +%s)
        if [ $((now - mtime)) -gt $LOCK_TIMEOUT ]; then
            log "[$name] lock timed out, breaking it."
            rmdir "$lock" 2>/dev/null
        fi
    fi

    if ! mkdir "$lock" 2>/dev/null; then
        log "[$name] locked"
        return 1
    fi

    trap 'rmdir "$lock" 2>/dev/null' EXIT INT TERM
    "$action" "$name" "$@"
    local ret=$?
    
    rmdir "$lock" 2>/dev/null
    trap - EXIT INT TERM
    return $ret
}

_check_process() {
    local name=$1
    local pfile="$STATE_DIR/$name.pid"
    [ ! -f "$pfile" ] && return 1

    local content=$(cat "$pfile")
    local s_pid=$(echo "$content" | cut -d: -f1)
    local s_mark=$(echo "$content" | cut -d: -f2)

    if [[ -z "$s_pid" ]]; then
        local ghost_pid=""
        
        if [[ "$OSTYPE" == "freebsd"* ]]; then
            if command -v procstat >/dev/null 2>&1; then
                ghost_pid=$(procstat -ea 2>/dev/null | grep "$MARKER_NAME=$s_mark" | awk '{print $1}' | head -n 1)
            fi
        else
            local match_file=$(grep -al "$MARKER_NAME=$s_mark" /proc/[0-9]*/environ 2>/dev/null | head -n 1)
            if [ -n "$match_file" ]; then
                ghost_pid=$(echo "$match_file" | awk -F/ '{print $3}')
            fi
        fi

        if [ -n "$ghost_pid" ]; then
            echo "$ghost_pid:$s_mark" > "$pfile"
            return 0
        fi
        return 1
    fi

    if kill -0 "$s_pid" 2>/dev/null; then
        local current_mark=$(_get_marker "$s_pid")
        if [[ "$current_mark" == "$s_mark" ]]; then
            return 0
        fi
    fi
    return 1
}

_do_start() {
    local name=$1; shift; local output=$1; shift
    local pfile="$STATE_DIR/$name.pid"
    
    local cmd_bin="$1"
    local bin_file=""
    
    if _check_process "$name"; then
        log "[$name] already running"
        return 0
    fi

    output=$(_trim "$output")

    if [ -z "$output" ]; then
        output="/dev/null"
    else
        output=$(bash -c "echo $output")
        if [[ "$output" != "/dev/null" ]]; then
            local log_dir=$(dirname "$output")
            if [ ! -d "$log_dir" ]; then
                mkdir -p "$log_dir"
            fi
        fi
    fi

    if [[ "$cmd_bin" == @* ]]; then
        local url="${cmd_bin#@}"
        bin_file="$STATE_DIR/$name.bin"
        rm -f "$bin_file"
        if ! _download_file "$url" "$bin_file"; then
            log "[$name] download failed"
            return 1
        fi
        chmod +x "$bin_file"
        shift
        set -- "$bin_file" "$@"
    fi

    local marker="$(date +%s)_$((RANDOM%1000))"
    echo ":$marker" > "$pfile"
    export "$MARKER_NAME"="$marker"

    nohup bash -c "exec $@" < /dev/null >> "$output" 2>&1 &
    local new_pid=$!
    
    echo "$new_pid:$marker" > "$pfile"
    log "[$name] started (pid: $new_pid)"

    if [ -n "$bin_file" ]; then
        sleep 0.5 
        rm -f "$bin_file" 2>/dev/null
    fi
}

_do_stop() {
    local name=$1; local pfile="$STATE_DIR/$name.pid"
    if _check_process "$name"; then
        local pid=$(cat "$pfile" | cut -d: -f1)
        kill "$pid"
        local retry=0
        while kill -0 "$pid" 2>/dev/null && [ $retry -lt $KILL_WAIT ]; do
            sleep 1; let retry++
        done
        [ $retry -eq $KILL_WAIT ] && kill -9 "$pid"
        rm -f "$pfile"
        log "[$name] stopped"
    else
        log "[$name] not running"
        rm -f "$pfile" 2>/dev/null
    fi
}

_do_status_print() {
    local name=$1
    if _check_process "$name"; then
        local pid=$(cat $name.pid | cut -d: -f1)
        printf "%-20s %-10s %s\n" "[$name]" "RUNNING" "(pid: $pid)"
    else
        printf "%-20s %-10s\n" "[$name]" "DOWN"
    fi
}

_validate_and_start() {
    local line="$1"
    
    if [[ "$line" =~ ^[[:space:]]*# ]]; then return 1; fi
    if [[ "$line" != *"|"* ]]; then return 1; fi

    IFS='|' read -r name output cmd <<< "$line"

    name=$(_trim "$name")
    output=$(_trim "$output")
    cmd=$(_trim "$cmd")

    [ -z "$name" ] || [ -z "$cmd" ] && return 1
    _with_lock "$name" "_do_start" "$output" $cmd
}

start() {
    if [ $# -eq 0 ]; then
        [ ! -f "$CONFIG_FILE" ] && return
        while read -r config; do
            local trimmed=$(_trim "$config")
            [[ -z "$trimmed" || "$trimmed" == \#* ]] && continue
            _validate_and_start "$config"
        done < "$CONFIG_FILE"
    else
        for name in "$@"; do
            local cfg=$(grep -E "^[[:space:]]*$name[[:space:]]*\|" "$CONFIG_FILE" | head -n 1)
            [ -n "$cfg" ] && _validate_and_start "$cfg" || log "no config: $name"
        done
    fi
}

stop() {
    if [ $# -eq 0 ]; then
        for pf in *.pid; do
            [ ! -f "$pf" ] && continue
            _with_lock "${pf%.*}" "_do_stop"
        done
    else
        for n in "$@"; do _with_lock "$n" "_do_stop"; done
    fi
}

restart() {
    if [ $# -eq 0 ]; then
        stop
        start
    else
        [ ! -f "$CONFIG_FILE" ] && { log "no config found"; return; }
        for name in "$@"; do
            local cfg=$(grep -E "^[[:space:]]*$name[[:space:]]*\|" "$CONFIG_FILE" | head -n 1)
            if [ -z "$cfg" ]; then
                log "no config found for $name"
            else
                _with_lock "$name" "_do_stop"
                _validate_and_start "$cfg"
            fi
        done
    fi
}

status() {
    if [ $# -eq 0 ]; then
        for pf in *.pid; do
            [ ! -f "$pf" ] && continue
            _with_lock "${pf%.*}" "_do_status_print"
        done
    else
        for name in "$@"; do
            _with_lock "$name" "_do_status_print"
        done
    fi
}

if [ $# -eq 0 ]; then
    echo "Usage: $0 {start|stop|restart|status|run} [service_name]"
else
    cmd=$1; shift
    case "$cmd" in
        "start")   start "$@" ;;
        "stop")    stop "$@" ;;
        "restart") restart "$@" ;;
        "status")  status "$@" ;;
        "run")     _validate_and_start "$*" ;;
        *)         echo "Invalid command: $cmd" ;;
    esac
fi

