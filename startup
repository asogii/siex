#!/bin/bash

ROOT_PATH=${START_UP_PATH:-$HOME/.startup}
CONFIG_FILE=${START_UP_CONFIG_PATH:-$ROOT_PATH/config}
KILL_WAIT=${START_UP_KILL_WAIT_TIME:-10}
TIME_ZONE=${START_UP_TIME_ZONE:-Asia/Shanghai}
LOCK_TIMEOUT=600 

MARKER_NAME="__STARTUP_${USER}_GUARD_UUID__"
STATE_DIR="$ROOT_PATH/states"

mkdir -p "$STATE_DIR"
cd "$STATE_DIR" || exit 1

log() {
    echo "[$(TZ=$TIME_ZONE date '+%F %T.%N')] $@"
}

_trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo -n "$var"
}

_get_marker() {
    local pid=$1
    if [[ "$OSTYPE" == "freebsd"* ]]; then
        if command -v procstat >/dev/null 2>&1; then
            procstat -e "$pid" 2>/dev/null | grep -o "$MARKER_NAME=[^ ]*" | cut -d= -f2
        fi
    else
        if [ -f "/proc/$pid/environ" ]; then
            grep -aaoZ "$MARKER_NAME=[^[:space:]]*" "/proc/$pid/environ" 2>/dev/null | cut -d= -f2 | tr -d '\0'
        else
            ps -p "$pid" -eww 2>/dev/null | grep -o "$MARKER_NAME=[^ ]*" | cut -d= -f2
        fi
    fi
}

_download_file() {
    local url=$1
    local out=$2
    log "downloading $url..."
    if command -v curl >/dev/null 2>&1; then
        curl -sL -o "$out" "$url"
    elif command -v wget >/dev/null 2>&1; then
        wget -qO "$out" "$url"
    else
        log "error: curl or wget not found"
        return 1
    fi
}

_with_lock() {
    local name=$1; local action=$2; shift 2
    local lock="$STATE_DIR/$name.lock"

    if [ -d "$lock" ]; then
        local mtime=$(stat -c %Y "$lock" 2>/dev/null || stat -f %m "$lock" 2>/dev/null)
        local now=$(date +%s)
        if [ $((now - mtime)) -gt $LOCK_TIMEOUT ]; then
            log "[$name] lock timed out, breaking it."
            rmdir "$lock" 2>/dev/null
        fi
    fi

    if ! mkdir "$lock" 2>/dev/null; then
        log "[$name] locked"
        return 1
    fi

    trap 'rmdir "$lock" 2>/dev/null' EXIT INT TERM
    "$action" "$name" "$@"
    local ret=$?
    
    rmdir "$lock" 2>/dev/null
    trap - EXIT INT TERM
    return $ret
}

_check_process() {
    local name=$1
    local pfile="$STATE_DIR/$name.pid"
    [ ! -f "$pfile" ] && return 1

    local content=$(cat "$pfile")
    local s_pid=$(echo "$content" | cut -d: -f1)
    local s_mark=$(echo "$content" | cut -d: -f2)

    if [[ -z "$s_pid" ]]; then
        local ghost_pid=""
        
        if [[ "$OSTYPE" == "freebsd"* ]]; then
            if command -v procstat >/dev/null 2>&1; then
                ghost_pid=$(procstat -ea 2>/dev/null | grep "$MARKER_NAME=$s_mark" | awk '{print $1}' | head -n 1)
            fi
        else
            ghost_pid=$(ps -axwwE 2>/dev/null | grep "$name" | grep "$MARKER_NAME=$s_mark" | awk '{print $1}' | head -n 1)
        fi

        if [ -n "$ghost_pid" ]; then
            echo "$ghost_pid:$s_mark" > "$pfile"
            return 0
        fi
        return 1
    fi

    if kill -0 "$s_pid" 2>/dev/null && [[ "$(_get_marker $s_pid)" == "$s_mark" ]]; then
        return 0
    fi
    return 1
}

_do_start() {
    local name=$1; shift; local output=$1; shift
    local pfile="$STATE_DIR/$name.pid"
    
    local cmd_bin="$1"
    local bin_file=""
    
    if _check_process "$name"; then
        log "[$name] running"
        return 0
    fi

    if [[ "$cmd_bin" == @* ]]; then
        local url="${cmd_bin#@}"
        bin_file="$STATE_DIR/$name.bin"
        rm -f "$bin_file"
        if ! _download_file "$url" "$bin_file"; then
            log "[$name] download failed"
            return 1
        fi
        chmod +x "$bin_file"
        shift
        set -- "$bin_file" "$@"
    fi

    local marker="$(date +%s)_$((RANDOM%1000))"
    echo ":$marker" > "$pfile"
    export "$MARKER_NAME"="$marker"

    nohup "$@" >> "$output" 2>&1 &
    local new_pid=$!
    
    echo "$new_pid:$marker" > "$pfile"
    log "[$name] started ($new_pid)"

    if [ -n "$bin_file" ]; then
        rm -f "$bin_file" 2>/dev/null
    fi
}

_do_stop() {
    local name=$1; local pfile="$STATE_DIR/$name.pid"
    if _check_process "$name"; then
        local pid=$(cat "$pfile" | cut -d: -f1)
        kill "$pid"
        local retry=0
        while kill -0 "$pid" 2>/dev/null && [ $retry -lt $KILL_WAIT ]; do
            sleep 1; let retry++
        done
        [ $retry -eq $KILL_WAIT ] && kill -9 "$pid"
        rm -f "$pfile"
        log "[$name] stopped"
    else
        log "[$name] down"
        rm -f "$pfile" 2>/dev/null
    fi
}

_do_status_print() {
    if _check_process "$1"; then
        log "[$1] running ($(cat $1.pid | cut -d: -f1))"
    else
        log "[$1] down"
    fi
}

_validate_and_start() {
    local line="$1"
    
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
        return 1
    fi

    if [[ "$line" != *"|"* ]]; then
        return 1
    fi

    line="${line//\$HOME/$HOME}"

    IFS='|' read -r name output cmd <<< "$line"

    name=$(_trim "$name")
    output=$(_trim "$output")
    cmd=$(_trim "$cmd")

    [ -z "$name" ] || [ -z "$output" ] || [ -z "$cmd" ] && return 1
    _with_lock "$name" "_do_start" "$output" $cmd
}

start() {
    if [ $# -eq 0 ]; then
        [ ! -f "$CONFIG_FILE" ] && return
        while read -r config; do
            local trimmed=$(_trim "$config")
            [[ -z "$trimmed" || "$trimmed" == \#* ]] && continue
            _validate_and_start "$config"
        done < "$CONFIG_FILE"
    else
        for name in "$@"; do
            local cfg=$(grep -E "^[[:space:]]*$name[[:space:]]*\|" "$CONFIG_FILE" | head -n 1)
            [ -n "$cfg" ] && _validate_and_start "$cfg" || log "no config: $name"
        done
    fi
}

stop() {
    if [ $# -eq 0 ]; then
        for pf in *.pid; do
            [ ! -f "$pf" ] && continue
            _with_lock "${pf%.*}" "_do_stop"
        done
    else
        for n in "$@"; do _with_lock "$n" "_do_stop"; done
    fi
}

restart() {
    if [ $# -eq 0 ]; then
        stop
        start
    else
        [ ! -f "$CONFIG_FILE" ] && { log "no config found"; return; }
        for name in "$@"; do
            local cfg=$(grep -E "^[[:space:]]*$name[[:space:]]*\|" "$CONFIG_FILE" | head -n 1)
            if [ -z "$cfg" ]; then
                log "no config found for $name"
            else
                _with_lock "$name" "_do_stop"
                _validate_and_start "$cfg"
            fi
        done
    fi
}

status() {
    if [ $# -eq 0 ]; then
        for pf in *.pid; do
            [ ! -f "$pf" ] && continue
            _with_lock "${pf%.*}" "_do_status_print"
        done
    else
        for name in "$@"; do
            _with_lock "$name" "_do_status_print"
        done
    fi
}

if [ $# -eq 0 ]; then
    echo "please specify command: start | stop | restart | status | run"
else
    cmd=$1; shift
    case "$cmd" in
        "start")   start "$@" ;;
        "stop")    stop "$@" ;;
        "restart") restart "$@" ;;
        "status")  status "$@" ;;
        "run")     _validate_and_start "$*" ;;
        "commands") echo "start stop restart status run" ;;
        *)         echo "command invalid: $cmd" ;;
    esac
fi

